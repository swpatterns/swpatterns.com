<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SWPatterns.com</title><link>http://example.org/</link><description>Recent content on SWPatterns.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 19 Mar 2021 11:01:47 +0100</lastBuildDate><atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml"/><item><title>Cargo Cult Programming</title><link>http://example.org/pattern/cargo_cult/</link><pubDate>Fri, 19 Mar 2021 11:01:47 +0100</pubDate><guid>http://example.org/pattern/cargo_cult/</guid><description>
&lt;p>Cargo Cult Programming gets its name from the Cargo Cults in Melanesia. The concept is simple: the hope that the same approach to a problem might solve an issue within our system without the understanding of both context and language or libraries.&lt;/p>
&lt;h2 id="examples">Examples&lt;/h2>
&lt;ul>
&lt;li>Copy and paste from StackOverflow without understanding of the code we copied and pasted&lt;/li>
&lt;li>On a business side, hoping that the actions done by someone else without recontextualization can lead to the same results in our case&lt;/li>
&lt;/ul></description></item><item><title>Observer</title><link>http://example.org/pattern/observer/</link><pubDate>Fri, 19 Mar 2021 10:45:34 +0100</pubDate><guid>http://example.org/pattern/observer/</guid><description>
&lt;p>Oberver Pattern enables the broadcast communication between an event subject, that emits changes to its state to all of its observers.&lt;/p>
&lt;h2 id="usage">Usage&lt;/h2>
&lt;p>Modern day usage is biased by the existence of rx and the reactive libraries across most important languages. Most modern libraries rely on observables and observers to get the most out of streams.&lt;/p>
&lt;h2 id="examples">Examples&lt;/h2>
&lt;p>The best example both usage and implementation is &lt;a href="http://reactivex.io/">http://reactivex.io/&lt;/a>. In Angular it is very common for data binding matters.&lt;/p></description></item><item><title>Adapter</title><link>http://example.org/pattern/adapter/</link><pubDate>Mon, 15 Mar 2021 13:24:44 +0100</pubDate><guid>http://example.org/pattern/adapter/</guid><description>
&lt;p>The adapter aims to be a converter between two specific interfaces: one belonging to &amp;ldquo;our&amp;rdquo; side of the application, the other to the library or other tool we need to interact with. This is very important, because it enables us to delay decisions, as the choice of a spcific implementation of the adapter becomes less important due to the fact that we are at that point using the adapter itself as our communication contract.&lt;/p>
&lt;h2 id="usage">Usage&lt;/h2>
&lt;p>Often used in combo with other patterns, such as [Inversion of Control] and several &lt;a href="http://example.org/pattern_types/factory/">Factories&lt;/a>&lt;/p>
&lt;h2 id="examples">Examples&lt;/h2>
&lt;p>Typical example of this pattern in a &amp;ldquo;pure&amp;rdquo; form is the Driver. Whether it is for printing or for database access, the API exposed by the common development systems just require the connection to the adapter and, with some kind of &lt;a href="http://example.org/pattern_types/factory/">Factory&lt;/a> or repository we get the specific implementation of what we need at the moment, based on the configuration of the system we have.&lt;/p></description></item><item><title>Singleton</title><link>http://example.org/pattern/singleton/</link><pubDate>Mon, 15 Mar 2021 13:24:44 +0100</pubDate><guid>http://example.org/pattern/singleton/</guid><description>
&lt;h2 id="intro">Intro&lt;/h2>
&lt;h2 id="usage">Usage&lt;/h2>
&lt;h2 id="examples">Examples&lt;/h2></description></item></channel></rss>